"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.autodetectServerAddress = void 0;
const Path = require("path");
const os = require("os");
const debug_1 = require("debug");
const ini_1 = require("./utils/ini");
const registry_1 = require("./utils/registry");
const network_1 = require("./utils/network");
const logger = (0, debug_1.default)('node-simconnect');
function findSimConnectPortIPv4() {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const port = yield (0, registry_1.readRegistryValue)('HKCU\\Software\\Microsoft\\Microsoft Games\\Flight Simulator', 'SimConnect_Port_IPv4');
            return parseInt(port, 10);
        }
        catch (_a) {
            return 2048;
        }
    });
}
function readNetworkConfigFromSimConnectCfg(folderPath, index) {
    return __awaiter(this, void 0, void 0, function* () {
        const filePath = Path.join(folderPath, 'SimConnect.cfg');
        let fullCfg;
        try {
            // SimConnect.cfg uses the INI fileformat
            fullCfg = yield (0, ini_1.readIniFile)(filePath);
        }
        catch (e) {
            logger('Could not read SimConnect.cfg due to to the following error:', e);
            return undefined;
        }
        if (fullCfg.SimConnect === undefined) {
            throw new Error(`Invalid SimConnect.cfg file: ${filePath}`);
        }
        const indexStr = index !== undefined ? index.toString(10) : '0';
        const cfg = fullCfg.SimConnect[indexStr] ? fullCfg.SimConnect[indexStr] : fullCfg.SimConnect;
        if (cfg.Protocol === undefined || cfg.Address === undefined || cfg.Port === undefined) {
            throw new Error(`The loaded SimConnect.cfg (${filePath}) is missing required parameters.`);
        }
        else if (cfg.Protocol && cfg.Protocol.toUpperCase() !== 'IPV4') {
            throw new Error('Only the Ipv4 protocol is supported at the moment');
        }
        return {
            type: 'ipv4',
            host: cfg.Address,
            port: parseInt(cfg.Port, 10),
        };
    });
}
function autodetectServerAddress(cfgIndex) {
    return __awaiter(this, void 0, void 0, function* () {
        // Check for SimConnect.cfg in current dir
        const localConfig = yield readNetworkConfigFromSimConnectCfg(process.cwd(), cfgIndex);
        if (localConfig)
            return localConfig;
        const homeConfig = yield readNetworkConfigFromSimConnectCfg(os.homedir(), cfgIndex);
        if (homeConfig)
            return homeConfig;
        if (cfgIndex !== undefined) {
            throw new Error(`No SimConnect.cfg file containing the given config index ${cfgIndex} was found`);
        }
        // Check if named pipe exist
        const PIPE = '\\\\.\\pipe\\Microsoft Flight Simulator\\SimConnect';
        const msfsSimconnectPipeOk = yield (0, network_1.checkIfNamedPipeExist)(PIPE);
        if (msfsSimconnectPipeOk) {
            return { type: 'pipe', address: PIPE };
        }
        // Read port number from Windows registry
        const ipv4port = yield findSimConnectPortIPv4();
        return { type: 'ipv4', host: 'localhost', port: ipv4port };
    });
}
exports.autodetectServerAddress = autodetectServerAddress;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29ubmVjdGlvblBhcmFtZXRlcnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvY29ubmVjdGlvblBhcmFtZXRlcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QixpQ0FBMEI7QUFDMUIscUNBQTBDO0FBQzFDLCtDQUFxRDtBQUNyRCw2Q0FBd0Q7QUFFeEQsTUFBTSxNQUFNLEdBQUcsSUFBQSxlQUFLLEVBQUMsaUJBQWlCLENBQUMsQ0FBQztBQUV4QyxTQUFlLHNCQUFzQjs7UUFDakMsSUFBSTtZQUNBLE1BQU0sSUFBSSxHQUFHLE1BQU0sSUFBQSw0QkFBaUIsRUFDaEMsOERBQThELEVBQzlELHNCQUFzQixDQUN6QixDQUFDO1lBQ0YsT0FBTyxRQUFRLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1NBQzdCO1FBQUMsV0FBTTtZQUNKLE9BQU8sSUFBSSxDQUFDO1NBQ2Y7SUFDTCxDQUFDO0NBQUE7QUFNRCxTQUFlLGtDQUFrQyxDQUM3QyxVQUFrQixFQUNsQixLQUFjOztRQUVkLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLGdCQUFnQixDQUFDLENBQUM7UUFFekQsSUFBSSxPQUFPLENBQUM7UUFDWixJQUFJO1lBQ0EseUNBQXlDO1lBQ3pDLE9BQU8sR0FBRyxNQUFNLElBQUEsaUJBQVcsRUFBQyxRQUFRLENBQUMsQ0FBQztTQUN6QztRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1IsTUFBTSxDQUFDLDhEQUE4RCxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQzFFLE9BQU8sU0FBUyxDQUFDO1NBQ3BCO1FBRUQsSUFBSSxPQUFPLENBQUMsVUFBVSxLQUFLLFNBQVMsRUFBRTtZQUNsQyxNQUFNLElBQUksS0FBSyxDQUFDLGdDQUFnQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO1NBQy9EO1FBRUQsTUFBTSxRQUFRLEdBQUcsS0FBSyxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO1FBQ2hFLE1BQU0sR0FBRyxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUM7UUFFN0YsSUFBSSxHQUFHLENBQUMsUUFBUSxLQUFLLFNBQVMsSUFBSSxHQUFHLENBQUMsT0FBTyxLQUFLLFNBQVMsSUFBSSxHQUFHLENBQUMsSUFBSSxLQUFLLFNBQVMsRUFBRTtZQUNuRixNQUFNLElBQUksS0FBSyxDQUFDLDhCQUE4QixRQUFRLG1DQUFtQyxDQUFDLENBQUM7U0FDOUY7YUFBTSxJQUFJLEdBQUcsQ0FBQyxRQUFRLElBQUksR0FBRyxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsS0FBSyxNQUFNLEVBQUU7WUFDOUQsTUFBTSxJQUFJLEtBQUssQ0FBQyxtREFBbUQsQ0FBQyxDQUFDO1NBQ3hFO1FBRUQsT0FBTztZQUNILElBQUksRUFBRSxNQUFNO1lBQ1osSUFBSSxFQUFFLEdBQUcsQ0FBQyxPQUFPO1lBQ2pCLElBQUksRUFBRSxRQUFRLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUM7U0FDL0IsQ0FBQztJQUNOLENBQUM7Q0FBQTtBQUVELFNBQWUsdUJBQXVCLENBQUMsUUFBaUI7O1FBQ3BELDBDQUEwQztRQUMxQyxNQUFNLFdBQVcsR0FBRyxNQUFNLGtDQUFrQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUN0RixJQUFJLFdBQVc7WUFBRSxPQUFPLFdBQVcsQ0FBQztRQUVwQyxNQUFNLFVBQVUsR0FBRyxNQUFNLGtDQUFrQyxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUNwRixJQUFJLFVBQVU7WUFBRSxPQUFPLFVBQVUsQ0FBQztRQUVsQyxJQUFJLFFBQVEsS0FBSyxTQUFTLEVBQUU7WUFDeEIsTUFBTSxJQUFJLEtBQUssQ0FDWCw0REFBNEQsUUFBUSxZQUFZLENBQ25GLENBQUM7U0FDTDtRQUVELDRCQUE0QjtRQUM1QixNQUFNLElBQUksR0FBRyxxREFBcUQsQ0FBQztRQUNuRSxNQUFNLG9CQUFvQixHQUFHLE1BQU0sSUFBQSwrQkFBcUIsRUFBQyxJQUFJLENBQUMsQ0FBQztRQUMvRCxJQUFJLG9CQUFvQixFQUFFO1lBQ3RCLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQztTQUMxQztRQUVELHlDQUF5QztRQUN6QyxNQUFNLFFBQVEsR0FBRyxNQUFNLHNCQUFzQixFQUFFLENBQUM7UUFDaEQsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLENBQUM7SUFDL0QsQ0FBQztDQUFBO0FBRVEsMERBQXVCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCAqIGFzIG9zIGZyb20gJ29zJztcbmltcG9ydCBkZWJ1ZyBmcm9tICdkZWJ1Zyc7XG5pbXBvcnQgeyByZWFkSW5pRmlsZSB9IGZyb20gJy4vdXRpbHMvaW5pJztcbmltcG9ydCB7IHJlYWRSZWdpc3RyeVZhbHVlIH0gZnJvbSAnLi91dGlscy9yZWdpc3RyeSc7XG5pbXBvcnQgeyBjaGVja0lmTmFtZWRQaXBlRXhpc3QgfSBmcm9tICcuL3V0aWxzL25ldHdvcmsnO1xuXG5jb25zdCBsb2dnZXIgPSBkZWJ1Zygnbm9kZS1zaW1jb25uZWN0Jyk7XG5cbmFzeW5jIGZ1bmN0aW9uIGZpbmRTaW1Db25uZWN0UG9ydElQdjQoKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBwb3J0ID0gYXdhaXQgcmVhZFJlZ2lzdHJ5VmFsdWUoXG4gICAgICAgICAgICAnSEtDVVxcXFxTb2Z0d2FyZVxcXFxNaWNyb3NvZnRcXFxcTWljcm9zb2Z0IEdhbWVzXFxcXEZsaWdodCBTaW11bGF0b3InLFxuICAgICAgICAgICAgJ1NpbUNvbm5lY3RfUG9ydF9JUHY0J1xuICAgICAgICApO1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQocG9ydCwgMTApO1xuICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gMjA0ODtcbiAgICB9XG59XG5cbmV4cG9ydCB0eXBlIENvbm5lY3Rpb25QYXJhbWV0ZXJzID1cbiAgICB8IHsgdHlwZTogJ3BpcGUnOyBhZGRyZXNzOiBzdHJpbmcgfVxuICAgIHwgeyB0eXBlOiAnaXB2NCc7IGhvc3Q6IHN0cmluZzsgcG9ydDogbnVtYmVyIH07XG5cbmFzeW5jIGZ1bmN0aW9uIHJlYWROZXR3b3JrQ29uZmlnRnJvbVNpbUNvbm5lY3RDZmcoXG4gICAgZm9sZGVyUGF0aDogc3RyaW5nLFxuICAgIGluZGV4PzogbnVtYmVyXG4pOiBQcm9taXNlPENvbm5lY3Rpb25QYXJhbWV0ZXJzIHwgdW5kZWZpbmVkPiB7XG4gICAgY29uc3QgZmlsZVBhdGggPSBQYXRoLmpvaW4oZm9sZGVyUGF0aCwgJ1NpbUNvbm5lY3QuY2ZnJyk7XG5cbiAgICBsZXQgZnVsbENmZztcbiAgICB0cnkge1xuICAgICAgICAvLyBTaW1Db25uZWN0LmNmZyB1c2VzIHRoZSBJTkkgZmlsZWZvcm1hdFxuICAgICAgICBmdWxsQ2ZnID0gYXdhaXQgcmVhZEluaUZpbGUoZmlsZVBhdGgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nZ2VyKCdDb3VsZCBub3QgcmVhZCBTaW1Db25uZWN0LmNmZyBkdWUgdG8gdG8gdGhlIGZvbGxvd2luZyBlcnJvcjonLCBlKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoZnVsbENmZy5TaW1Db25uZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFNpbUNvbm5lY3QuY2ZnIGZpbGU6ICR7ZmlsZVBhdGh9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5kZXhTdHIgPSBpbmRleCAhPT0gdW5kZWZpbmVkID8gaW5kZXgudG9TdHJpbmcoMTApIDogJzAnO1xuICAgIGNvbnN0IGNmZyA9IGZ1bGxDZmcuU2ltQ29ubmVjdFtpbmRleFN0cl0gPyBmdWxsQ2ZnLlNpbUNvbm5lY3RbaW5kZXhTdHJdIDogZnVsbENmZy5TaW1Db25uZWN0O1xuXG4gICAgaWYgKGNmZy5Qcm90b2NvbCA9PT0gdW5kZWZpbmVkIHx8IGNmZy5BZGRyZXNzID09PSB1bmRlZmluZWQgfHwgY2ZnLlBvcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBsb2FkZWQgU2ltQ29ubmVjdC5jZmcgKCR7ZmlsZVBhdGh9KSBpcyBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcnMuYCk7XG4gICAgfSBlbHNlIGlmIChjZmcuUHJvdG9jb2wgJiYgY2ZnLlByb3RvY29sLnRvVXBwZXJDYXNlKCkgIT09ICdJUFY0Jykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgdGhlIElwdjQgcHJvdG9jb2wgaXMgc3VwcG9ydGVkIGF0IHRoZSBtb21lbnQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnaXB2NCcsXG4gICAgICAgIGhvc3Q6IGNmZy5BZGRyZXNzLFxuICAgICAgICBwb3J0OiBwYXJzZUludChjZmcuUG9ydCwgMTApLFxuICAgIH07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGF1dG9kZXRlY3RTZXJ2ZXJBZGRyZXNzKGNmZ0luZGV4PzogbnVtYmVyKTogUHJvbWlzZTxDb25uZWN0aW9uUGFyYW1ldGVycz4ge1xuICAgIC8vIENoZWNrIGZvciBTaW1Db25uZWN0LmNmZyBpbiBjdXJyZW50IGRpclxuICAgIGNvbnN0IGxvY2FsQ29uZmlnID0gYXdhaXQgcmVhZE5ldHdvcmtDb25maWdGcm9tU2ltQ29ubmVjdENmZyhwcm9jZXNzLmN3ZCgpLCBjZmdJbmRleCk7XG4gICAgaWYgKGxvY2FsQ29uZmlnKSByZXR1cm4gbG9jYWxDb25maWc7XG5cbiAgICBjb25zdCBob21lQ29uZmlnID0gYXdhaXQgcmVhZE5ldHdvcmtDb25maWdGcm9tU2ltQ29ubmVjdENmZyhvcy5ob21lZGlyKCksIGNmZ0luZGV4KTtcbiAgICBpZiAoaG9tZUNvbmZpZykgcmV0dXJuIGhvbWVDb25maWc7XG5cbiAgICBpZiAoY2ZnSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgTm8gU2ltQ29ubmVjdC5jZmcgZmlsZSBjb250YWluaW5nIHRoZSBnaXZlbiBjb25maWcgaW5kZXggJHtjZmdJbmRleH0gd2FzIGZvdW5kYFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIG5hbWVkIHBpcGUgZXhpc3RcbiAgICBjb25zdCBQSVBFID0gJ1xcXFxcXFxcLlxcXFxwaXBlXFxcXE1pY3Jvc29mdCBGbGlnaHQgU2ltdWxhdG9yXFxcXFNpbUNvbm5lY3QnO1xuICAgIGNvbnN0IG1zZnNTaW1jb25uZWN0UGlwZU9rID0gYXdhaXQgY2hlY2tJZk5hbWVkUGlwZUV4aXN0KFBJUEUpO1xuICAgIGlmIChtc2ZzU2ltY29ubmVjdFBpcGVPaykge1xuICAgICAgICByZXR1cm4geyB0eXBlOiAncGlwZScsIGFkZHJlc3M6IFBJUEUgfTtcbiAgICB9XG5cbiAgICAvLyBSZWFkIHBvcnQgbnVtYmVyIGZyb20gV2luZG93cyByZWdpc3RyeVxuICAgIGNvbnN0IGlwdjRwb3J0ID0gYXdhaXQgZmluZFNpbUNvbm5lY3RQb3J0SVB2NCgpO1xuICAgIHJldHVybiB7IHR5cGU6ICdpcHY0JywgaG9zdDogJ2xvY2FsaG9zdCcsIHBvcnQ6IGlwdjRwb3J0IH07XG59XG5cbmV4cG9ydCB7IGF1dG9kZXRlY3RTZXJ2ZXJBZGRyZXNzIH07XG4iXX0=