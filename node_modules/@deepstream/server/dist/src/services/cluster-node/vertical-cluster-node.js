"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VerticalClusterNode = void 0;
const constants_1 = require("../../constants");
const cluster = require("cluster");
const events_1 = require("events");
const types_1 = require("@deepstream/types");
if (cluster.isMaster) {
    cluster.on('message', (worker, serializedMessage, handle) => {
        for (const id in cluster.workers) {
            const toWorker = cluster.workers[id];
            if (toWorker !== worker) {
                toWorker.send(serializedMessage);
            }
        }
    });
}
class VerticalClusterNode extends types_1.DeepstreamPlugin {
    constructor(pluginConfig, services, config) {
        super();
        this.services = services;
        this.config = config;
        this.description = 'Vertical Cluster Message Bus';
        this.isReady = false;
        this.callbacks = new Map();
    }
    init() {
        if (cluster.isWorker) {
            process.on('message', (serializedMessage) => {
                if (this.isReady) {
                    const { fromServer, message } = JSON.parse(serializedMessage);
                    VerticalClusterNode.emitter.emit(constants_1.TOPIC[message.topic], message, fromServer);
                    const callbacks = this.callbacks.get(constants_1.TOPIC[message.topic]);
                    if (!callbacks || callbacks.size === 0) {
                        this.services.logger.warn(types_1.EVENT.PLUGIN_ERROR, `Received message for unknown topic ${constants_1.TOPIC[message.topic]}`);
                        return;
                    }
                    callbacks.forEach((callback) => callback(message, fromServer));
                }
            });
        }
    }
    async whenReady() {
        this.isReady = true;
    }
    send(message, metaData) {
        process.send(JSON.stringify({ message, fromServer: this.config.serverName }));
    }
    sendDirect(serverName, message, metaData) {
        process.send(JSON.stringify({ toServer: serverName, fromServer: this.config.serverName, message }));
    }
    subscribe(stateRegistryTopic, callback) {
        VerticalClusterNode.emitter.on(constants_1.TOPIC[stateRegistryTopic], callback);
        let callbacks = this.callbacks.get(constants_1.TOPIC[stateRegistryTopic]);
        if (!callbacks) {
            callbacks = new Set();
            this.callbacks.set(constants_1.TOPIC[stateRegistryTopic], callbacks);
        }
        callbacks.add(callback);
    }
    async close() {
        for (const [topic, callbacks] of this.callbacks) {
            for (const callback of callbacks) {
                VerticalClusterNode.emitter.off(topic, callback);
            }
        }
        this.callbacks.clear();
        this.isReady = false;
    }
}
exports.VerticalClusterNode = VerticalClusterNode;
VerticalClusterNode.emitter = new events_1.EventEmitter();
//# sourceMappingURL=vertical-cluster-node.js.map